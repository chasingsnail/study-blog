## Web 端的绘图方式

### HTML + CSS

呈现普通的网页。

简单的图表功能可以通过 CSS 中的布局、渐变等属性来实现。这种方式不需要引入额外的库，节省了资源。

但缺点的同样明显：

+ 绘制方式不够简洁，难以看出数据与图形之间的关系，换算关系需要开发人员来维护。
+ HTML 与 CSS 本身作为浏览器渲染引擎的一部分，在处理页面渲染的工作外，如果还需要绘制可视化图表，性能开销较大。

相比于 Canvas2D 与 WebGL ，后两者能够直接操作绘图上下文，在重绘图像时，也不会发生重新解析文档和构建的过程。

### SVG

SVG 是一种基于 XML 愈发的图像隔世，可以通过 img 标签的 src 属性加载。浏览器本身可以内嵌 SVG 标签，并且利用 DOM API 来操作。

```html
  <svg xmlns="http://www.w3.org/2000/svg" width="120px" height="240px" viewBox="0 0 60 100">
    <g transform="translate(0, 100) scale(1, -1)">
      <g>
        <rect x="1" y="0" width="10" height="25" fill="#37c"/>
        <rect x="13" y="0" width="10" height="26" fill="#37c"/>
        <rect x="25" y="0" width="10" height="40" fill="#37c"/>
        <rect x="37" y="0" width="10" height="45" fill="#37c"/>
        <rect x="49" y="0" width="10" height="68" fill="#37c"/>
      </g>
    </g>
  </svg>
```

相比较于 CSS 的绘图，SVG 更能够直观地展示出元素属性与数值的关系，而不需要进行转换。

SVG 弥补了 HTML 在绘制矢量图形方面的不足，同时对于不规则图形的处理也变得更加简单。

SVG 的缺点同样是需要占用渲染引擎资源，大量的 SVG 元素会占用很多内存空间，增加渲染开销。因此 SVG 通常适用于元素较少的简单可视化场景。

### Canvas2D

Canvas2D 是浏览器提供的简便快捷的指令式图形系统，它通过一些简单的指令就能快速绘制出复杂的图形。由于它直接操作绘图上下文，因此没有 HTML/CSS 和 SVG 绘图因为元素多导致消耗性能的问题，性能要比前两者快得多。但是如果要绘制的图形太多，或者处理大量的像素计算时，Canvas2D 依然会遇到性能瓶颈。

Canvas 不方便的地方在于，相比于 HTML 和 SVG 可以方便地操作它们（如注册点击事件），在 Canvas 画布上难以进行局部的控制，需要通过定位的方式来获取局部图形。

Cavans 可以与 SVG 结合使用，先使用 SVG 生成某些图形，然后用 Canvas 将起作为 image 元素添加到画布中来渲染。

### WebGL

浏览器提供的 CanvasAPI 中的另一种上下文，它是 OpenGL ES 规范在 Web 端的实现。可以通过它，用 GPU 渲染各种复杂的 2D 和 3D 图形。WebGL 用了 GPU 并行处理的特性，因此在处理大量数据展示的时候，性能优于上述 3 中国呢方式。适用于数据量大，效果要求高的特殊场景：

+ 绘制的图形数量非常多。例如有数万个几何图形需要绘制且它们的位置在不停变化
+ 需要对较大图像进行细节像素处理。例如实体物体的光影、流体效果。需要精确改变局部区域的所有像素点，这是需要计算的像素点的数量是非常多的
+ 绘制 3D 物体

Cavans2D 渲染只能够由浏览器底层控制，无法自身控制 GPU，因此很多优化浏览器无法代替开发者去做。而 WebGL 会将数据写入帧缓冲中，通过 WebGL Program 来执行 shader 完成图形渲染，因此 WebGL 能够自己控制 GPU 渲染。

很多图形的计算中，WebGL 都可以放到 shader 计算，这样比 JS 计算块，也更灵活。

### Remain

+ SVG 实现饼图、折线图和面积图
+ Canvas 实现柱状图