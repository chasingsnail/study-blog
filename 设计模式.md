# 五大原则 SOLID

+ S 单一职责原则
  + 一个程序只做好一件事
  + 如果功能过于复杂，则进行拆分，保持每个部分的独立
+ O 开放封闭原则
  + 对扩展开放，对修改封闭
  + 新增需求时扩展新代码，而非修改已有代码
+ L 李氏置换原则
+ I 接口独立原则
+ D 依赖导致原则

# 设计模式

## 工厂模式

例如 React.createElement 、Vue $createElement 是一个工厂模式，返回一个 Vnode 实例。

## 单例模式

保证一个类仅有一个实例，并且提供一个访问到它的全局访问方法。

```js
var Singleton = function (name) {
  this.name = name
}
Singleton.instance = null
Singleton.prototype.getInstance = function (name) {
  if (!this.instance) {
    this.instance = new Singleton(name)
  }
  return this.instance
}

var a = Singleton.getInstance('a')
var b = Singleton.getInstance('b')
// a === b
```

全局对象不是单例模式，但是经常在开发中被用作单例。

### 惰性单例

惰性单例是指在需要的时候才去创建对象实例。

例如全局唯一的登录框，仅在用户点击登录时才创建弹出，而不是在一开始就创建完成并隐藏。

在**单一职责原则**下，可以将管理单例的逻辑抽离：

```js
var getSingle = function (fn) {
  var result
  return function() {
    return result || (result = fn.apply(this, arguments))
  }
}

// create div
var createDiv = function() {
  var div = document.createElement('div')
  div.innerHtml = 'hello'
  div.style.display = 'none'
  return div
}

var createSingleDiv = getSingle(createDiv);

// 在需要时调用
button.onclick = function() {
  let div = createSingleDiv();
  div.style.display = 'block'
}
```

应用

+ jq 的 $
+ vuex 的 store

## 适配器模式

适配器模式黄祖耀用来解决已有的接口不匹配的问题，它不需要改变原有的接口，通过包装来适配原有的方法。

实际中的应用有二次封装库提供的方法；Vue 中的计算属性。

```js
// 封装 jQuery 中的 ajax
window.ajax = function (options) {
  $.ajax(options)
}
```

该模式符合开放封闭原则，并且将旧接口与使用者分离。

