[巩固你的HTTP知识体系](https://juejin.im/post/6857287743966281736)

TCP

概念、与 UDP 区别、三次握手、四次挥手

https://juejin.im/post/6844904070889603085

前端代码部署

https://www.zhihu.com/question/20790576/answer/32602154



## HTTP

超文本传输协议

### 特点

+ 灵活可拓展，可以传输文本、图片、视频等
+ 请求 - 应答模式
+ 可靠，基于 TCP/IP
+ 无状态，**请求都是独立的**，服务器不会记录客户端状态，不知道客户端是谁除非客户端带上自己的状态（依靠 cookie、session），对于同一个接口的请求也没有上下文关系。
+ 明文传输，将报文暴露给外界

### 1.0/1.1/1.2 区别

#### 1.0

+ 引入了 POST 和 HEAD
+ 不支持断点续传
+ 非持久连接，每次请求都需要重新建立 tcp 连接，增加了通信的开销

#### 1.1 

最主流的版本

+ 引入持久连接，TCP 连接默认不关闭（Keep-Alive），tcp 连接可以被多个请求复用
+ 在同一个 TCP 连接里，客户端可以同时发送多个请求
+ 增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效
+ 支持断点续传
+ 新增 PUT、PATCH、OPTIONS、DELETE 

### 1.x 版本的问题

+ 传输数据明文
+ 允许复用 TCP 连接的前提下，在同一个 TCP 连接内每次只能够处理一个回应，可能会造成**队头阻塞**。如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。
+ 默认开启 keep-alive 的情况下可能会给服务器带来压力，可能存在请求之后还保持了长时间不必要的连接

### 2.0

+ 二进制分帧： 之前是明文传输，2.0 采用了二进制的格式， 头信息和数据体都是二进制，统称为帧
+ 头部压缩：1.1 版本会出现头部偏重（**User-Agent、Cookie、Accept、Server、Range**等字段占用过多）而 body 偏小的情况，在 2.0 中使用了算法进行压缩
+ 多路复用 ：同样是复用 TCP 连接，**在一个连接里，客户端和浏览器都可以同时发送多个请求**，单个连接可以承载任意数量的双向数据流，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着流（流是帧的分组集合，同一个流中的帧是交错传输的）中的消息。并行地在同一个 TCP 连接上双向交换消息。
+ 服务器推送：允许服务器未经请求，主动向服务端发送资源，即服务器推送
+ 请求优先级：可以设置数据帧的优先级，让服务端优先处理重要资源

### 3.0

+ 避免包阻塞：多个流的数据包在 tcp 上传输时，如果一个流中的包出现了问题，那么 tcp 需要等到这个包重传后才能继续传输其他流的数据包。3.0 中实现不同流之间的数据相互独立，出现问题时不会影响其他流
+ 快速重启会话：当网络切换的时候，会改变 ip，导致需要 tcp 重新连接创建，3.0 中使用 uuid 来标记每一次连接，在网络环境切换的时候，只要这个标识不变，就不需要再重新握手

## Keep-Alive

目的在于使客户端到服务器端的连接持续有效，让多次的 http 请求复用同一个 tcp 连接，从而减少创建关闭多个 tcp 连接的开销。

开启方法是在头部增加 `connection: Keep-Alive`，1.1 默认启用。关闭则需要设置 `Connection: close`

需要依赖服务器的设置情况

## 队头阻塞问题

对于每一个 HTTP 请求而言，任务会被放入任务队列中串行执行，一旦队头的任务请求太慢，就会阻塞后面的请求处理。

解决办法：

+ 并发：一个域名可以分配多个长连接，即增加了任务队列。Chrome 中是 6 个
+ 域名分片：可以划分出多个二级域名，指向同一个服务器。这样可以增加并发处理的任务队列。例如 test.com 划分出 child1.test.com 、child2.test.com

## 状态码

+ 1xx  请求已经接受，需要继续处理
+ 2xx 成功状态
  + 200 OK 表示客户端请求在服务器端被正确请求
  + 204 请求成功但无资源返回
  + 206 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 **「Content-Range」** 指定范围的实体内容。
+ 3xx 重定向
  + 301 永久重定向，表示资源已经分配了新的 URL
  + 302 临时重定向，表示资源临时被分配了新的 URL
  + 303 表示资源存在另一个 URL，应使用 GET 方法获取资源
  + 304 命中**协商缓存**
  + 307 临时重定向，不会改变 method。由于 301、302、303 返回时，浏览器会将 post 改成 get，自动再次发送。
+ 4xx 客户端错误
  + 400 请求报文语法错误
  + 401 表示发送的请求需要有通过 HTTP 认证的认证信息。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  + 403 请求资源访问被拒绝
  + 404 没找到该资源
  + 405 禁止使用该请求方式，通常客户端可以通过 options 方法进行预检，查看服务器允许的方法 `Access-Control-Allow-Methods`
+ 5xx 服务器错误
  + 500 服务器执行请求时错误
  + 502 服务器自身正常，访问时出现了未知问题
  + 503 服务器超负荷或停机维护，无法处理请求



## DNS

DNS 协议提供的是一种**主机名到 ip 地址的转换服务**。应用层协议，运行在 UDP 协议之上（**为了避免使用 TCP 协议时造成的连接时延**）。

DNS 服务器收到一个 DNS 回答后，能够将回答中的信息缓存在本地存储器中。

### DNS 实现负载均衡

在网站使用多台服务器时，一个域名会对应多个服务器地址。在用户发起网站域名的 DNS 请求时，会返回域名对应的服务器 ip 集合，在每个回答中会循环这些 ip 地址的顺序，用户会选择排在前面的地址发送请求，以此实现将用户请求均衡地分配到各个不同服务器上。

该方法的问题在于，如果一个服务器有问题时，由于 DNS 服务器中有缓存，会仍然将域名解析为可能发生故障的服务器 ip。



## HTTP 缓存

缓存是性能优化的一个重要手段。分为强缓存和协商缓存，强缓存不经服务器，而协商缓存需要。两者同时存在是强缓存优先。

### 强缓存

直接使用本地缓存，不用和服务器进行通信

相关字段：Expires（1.0 版本），Cache-Control（1.1 版本）

首先检查强缓存，这个阶段不需要发送 HTTP 请求。通过上述两个字段来进行判断。

#### Expires

过期时间，时间是相对于服务器来说。存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里获取数据，无需再次请求

```
Expires:Mon, 29 Jun 2020 11:10:23 GMT
```

由于**服务器时间与浏览器时间可能不一致**，因此在 1.1 版本中使用 Cache-Control 来替代

#### Cache-Control 

- private：客户端可以缓存
- public：客户端和代理服务器都可以缓存
- max-age=t：缓存内容将在t秒后失效
- no-cache：不使用本地缓存。需要使用协商缓存来验证缓存数据，因此是需要去向服务器验证缓存是否可用
- no-store：所有内容都不会缓存

```
Cache-Control:max-age=6000
```

表示资源返回后 6000 秒，可以直接使用缓存

#### 注意点

+ 当上述两个字段同时存在时，优先考虑 Cache-Control 
+ 没有命中强缓存时，会进入协商缓存

### 协商缓存

将资源一些相关信息返回服务器，让服务器判断浏览器是否能直接使用本地缓存，整个过程至少与服务器通信一次。

强缓存失效后，浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，浏览器再次请求时，请求头中携带响应的`缓存相关的Tag`来向服务器发送请求，服务器根据对应的 tag，来决定是否使用缓存。未失效则返回 304。

缓存分为两种，**Last-Modified** 和 **ETag**。两者各有优势，并不存在谁对谁有`绝对的优势`，与上面所讲的强缓存两个Tag所不同。

#### Last-Modified

资源最后的修改时间。

+ if-Modified-Since

  在浏览器第一次给服务器发请求时，会在响应头中加上这个字段。浏览器再次请求时，会在请求头中携带 **If-Modified-Since** 字段这个值就是服务器传来的最后修改时间。服务器拿到这个字段后会与该资源的最后修改时间进行对比，如果小于最后修改时间，说明该资源已经更新过了，返回新的资源。否则返回 304，告诉浏览器使用缓存。

+ if-Unmodified-Since

  从某个时间点开始，文件是否没有被修改，如果没有被修改，返回200。反之返回 412 （预处理错误）

#### ETag

服务器根据当前文件内容，生成文件唯一标识。如果资源内容修改，这个值就修改。

+ if-None-Match

  服务器同样会通过响应头 ETag 把该字段告诉浏览器，浏览器下次请求该资源时，会携带 **If-None-Match** 这个字段。服务器收到后会与该资源的 ETag 进行对比，如果不同则说明内容更新，返回新资源。否则返回 304，使用缓存。

+ if-Match

  与前者相反，相同执行请求，否则拒绝（412）

#### 二者对比

性能上考量，Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，因此 Last-Modified 优于 ETag。

从精确程度上看，ETag 更优。在某些情况下，例如编辑了资源文件但文件内容没有改变，或是1秒内改变了多次（最小粒度只到 s， s 以内的改动无法检测到）的情况， Last-Modified 不能够很好的判断。

如果两种方法都支持的情况，服务器优先考虑 ETag

### 缓存位置

浏览器缓存的存放位置分四种，按优先级从高到低：

1. Service Worker

   多应用于 PWA 场景，能够完成**离线缓存**的功能

2. Memory Cache

   内存缓存，效率最高。浏览器关闭后，内存缓存也不存在了。

3. Disk Cache

   磁盘缓存，存取效率低于内存缓存，优势在于存储容量与存储时长，大的资源文件（图片、js、css）优先考虑存放在 Disk

4. Push Cache

   推送缓存



## 请求方法

HTTP 1.0 GET｜POST｜HEAD

HTTP 1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

### GET 与 POST 的区别

+ 通常在对于参数的处理上，get 请求会放在 URL 中，POST 则会放在 body 请求体中，相对而言安全一些，但在抓包的情况下都一样
+ GET 请求要经过 URL 编码，只能够接受 ASCII 码，POST 支持更多中编码类型且不对数据类型限制
+ 缓存角度来说，GET 请求后浏览器会主动缓存
+ GET 请求会一次性发送请求报文，POST 请求通常分为两个 TCP 包，首先发送 header 部分，服务器响应 100 后，在发送 body 部分

### OPTIONS 的作用

这个方法会返回该资源所支持的所有 HTTP 方法，在 CORS 跨域资源共享时，对于非简单请求会先发送一次 OPTIONS 请求，判断是否有访问的权限（请求方法以及 header 额外字段）。

## 跨域

### 背景

+ 同源策略限制（协议，端口和域名相同）
+ 同源策略限制：针对接口的请求、DOM 的查询、Cookie、LocalStorage 和 IndexDB 无法读取。
+ 无同源策略的影响
  + CSRF 攻击，钓鱼网站跨域发送请求获取了 Cookie 鉴权信息

### 方法

#### JSONP

script 标签没有同源策略限制，因此可以通过 script 标签 发起一个请求，前端把回调函数的名称（前后端可约定）放到请求的 query 参数里面。然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，前端的 script 标签请求到这个执行的回调函数后会立马执行，这样前端就可以随意定制自己的函数来自动处理返回数据了。

可通过超时来判断是否加载失败。具体实现方案可以设置一个定时器，回调是一个错误处理，和一个变量，当成功返回时候置为 true，否则一直是 false。当定时器下限到的时候，如果变量仍然是 false，则执行错误处理回调

缺点：只能支持 Get 请求

#### CORS（跨域资源共享）

允许浏览器向跨源服务器发送请求，需要浏览器端和服务器端同时支持。一般浏览器都能够支持，因此服务端配合支持即可。

CORS 请求分简单与非简单请求。简单请求可以看作是普通 HTML Form 不依赖脚本可以发出的请求，而非简单请求就是普通 Form 无法实现的请求。

简单请求同时满足请求方法为 HEAD、GET、POST 且 HTTP 头部信息不超出固定字段（若 ContentTtype 为 json 也不满足）。

如果服务端设置 Access-Control-Allow-Origin 为 * ，则不会带上 Cookie 信息。如果需要传递 Cookie 则需要指定 origin，且设置 credentials。

非简单请求中会首先发一次预检测（OPTIONS 方法），询问当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段，返回码是 204，如通过才发出真正的请求返回 200.

预检查除了设置 origin，**还需要设置 Access-Control-Request-Method**（检查请求方式是否支持） 以及 Access-Control-Request-Headers（**指定浏览器CORS请求会额外发送的头信息字段**）。

```js
// koa 配置 cors
// 处理cors
app.use(cors({
  origin: function (ctx) {
    return 'http://localhost:9099'
  },
  credentials: true,
  allowMethods: ['GET', 'POST', 'DELETE'],
  allowHeaders: ['t', 'Content-Type']
}))
```

CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP 只支持`GET`请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

## HTTPS

### http 问题

+ 通信使用明文

+ 报文可能被修改，无法验证报文完整性

+ 不验证通信方的身份

  **HTTP协议中的请求和响应不会对通信方进行确认**。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。

HTTPS 是由 HTTP + TLS/SSL 协议组合而成。由后者来保障安全性。

与 HTTP 的区别在于：

+ HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
+ HTTPS 对于 SEO 更为友好，谷歌、百度会优先检索 HTTPS 网页
+ HTTPS 标准端口 443，HTTP 标准端口为 80
+ HTTPS 需要 SSL 证书

优势

+ 内容经过加密，每个连接会生成唯一的密钥
+ 传输经过完整性验证
+ 身份认证

主要作用：

+ 对数据进行加密，建立一个信息安全通道
+ 对网站服务区进行真实身份认证

### 工作原理

基于 TLS/SSL 的功能，依赖三类基本算法：散列函数（信息完整）、对称加密（信息加密）、非对称加密（身份验证）

#### 对称加密的情况

这种方式的加密与解密需要同一个密钥，转发密钥的时候，可能会导致密钥泄漏。无法保证密钥传输的安全性。

#### 非对称加密

这种方式需要一对密钥，公钥和私钥。公钥可以随意发布，私钥不行。发送秘文的一方使用公钥来加密，接受方通过自己的私钥进行解密。这种方式的缺点在于：

+ 公钥匙公开的，所以针对于使用私钥加密的内容，可以通过公钥来解密
+ 公钥不包含服务器信息，无法确认服务器身份，公钥可能会被篡改
+ 加密解密需要**消耗一定的时间**

#### 对称加密与非对称加密结合

客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个**「对称加密的秘钥」**，使用**「该公钥」**加密，传输给服务端，服务端再通过自己的**私钥**解密拿到该**「对称秘钥」**，后续的所有信息都通过该**「对称秘钥」**进行加密解密，完成整个HTTPS的流程。公钥的传输需要通过注册一个证书，来保证公钥的传输。

这种方法需要引入证书颁发机构（CA），存储利用私钥加密后的公钥，客户端用机构的公钥（存放在客户端电脑）去解密。服务端第一次返回的证书会通过验证 hash 来保证证书不被篡改。但这样的做法不是绝对的安全，如果不小心安装了黑客的恶意证书，客户端电脑就会多一个公钥，因此不能随意安装根证书。

TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。

1. 客户端: 你好，我要发起一个 HTTPS 请求，请给我公钥
2. 服务器: 好的，这是我的证书，里面有加密后的公钥
3. 客户端: 解密成功以后告诉服务器: 这是我的 (用公钥加密后的) 对称秘钥。
4. 服务器: 好的，我知道你的秘钥了，后续就用它传输。

## 网络安全

### XSS（跨站脚本攻击）

代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

+ 内嵌文本内容，以 script 标签注入
+ href 属性中包含 javascript: 等可以执行代码
+ 通过 innerHTML 等 API 时，把不可信的数据作为 HTML 插入到页面上

防范手段：

+ 将用户输入的文本进行过滤
+ HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
+ 验证码：防止脚本冒充用户提交危险操作。
+ 正确选择转义库，因为不同的上下文需要的转义规则不一致（跳转链接、内嵌 JS 字符串等）

### CSRF（跨站请求伪造）

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

通常的攻击方式有 

+ get 类型：利用图片链接，加载图片时会自动向目标地址发起请求
+ post 类型：通常使用一个自动提交的表单（在页面上隐藏），在访问页面时自动提交。
+ 链接类型：用户点击某个链接后出发，可能是广告图片 （可在本域下攻击）

CSRF 通常是跨域的，但是本域下会被利用，例如发图片和链接的论坛。

#### 攻击流程

1. 用户登陆了 a 网站，拿到了对应的 cookie
2. 这时钓鱼网站引导用户访问了 b 网站
3. 此时 b 向 a 发送了一个请求，这时候浏览器会默认携带 a 的 Cookie
4. 那么当 a 收到请求后，通过 cookie 验证，误以为是用户自己发送的请求
5. a 执行了请求响应的操作后，钓鱼网站完成了攻击

#### 防御手段

+ 不让第三方网站访问到 Cookie。利用 Chrome 下的 **SameSite** 属性。
  + Strict：严格模式，这种模式下 Cookie 不能用做任何第三方 Cookie
  + Lax：宽松模式，如果请求是 get 请求，可以作为第三方 Cookie
  + 但 SameSite 兼容性不够好，要根据浏览器来判断是否需要添加；不支持子域名，多个子域名用户需要重新登陆。
+ 通过 Origin、Referer 头部标记访问来源
+ 在请求时携带一个 Token，攻击者无法窃取到 Cookie，仅仅只是冒用 Cookie 中的信息，因此可以通过在请求中携带一个 Token，服务器来校验携带的 Token 是否正确。
+ 双重 Cookie 验证
  + 往请求域名中注入一个 Cookie，发起请求时，需要将这个字段带到 url 参数中
  + 后端接口校验 Cookie 中的字段是否和参数重的字段一致
  + 这样做的优势在于不需要使用 Session，且 Token 存储在客户端不会给服务器带来压力。前后端可以统一拦截校验
+ 输入验证码和二次输入密码

## WebSocket

WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。

使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。



## 代理服务器

代理服务器就是介于客户端和服务端之间的服务器。HTTP 请求通过代理服务器转发给服务器，再将服务器的响应返回给客户端。

### 正向代理

客户端向代理服务器发出请求，并**指明了目标访问服务器**。接着代理服务器向目标服务器转发请求，获取内容后返回客户端。

在正向代理中，隐藏了真实的请求客户端，服务端不知道正是请求的客户是谁。

例：科学上网

### 反向代理

从客户端向服务端发起请求，代理服务器收到请求后自行判断访问那个服务器，再将最后的结果返回给客户端。

在反向代理中，隐藏了真实的服务器，客户端不需要知道是哪一台服务器提供了服务。

这种方式常用于实现**负载均衡**，例如 Nginx



## 负载均衡

### 反向代理

用户的请求都发送到反向代理服务器上，由反向代理服务器（例如 Nginx）将请求转发到真实的服务器上，实现负载均衡。

### DNS

参考 DNS 部分



## TCP/IP 

TCP 协议是传输层协议，面向连接的、可靠的、基于字节流的传输层通信协议

+ 面向连接，例如三次握手，四次挥手都是针对连接
+ 一条连接只有两个端点
+ 可靠
+ 全双工：连接双方可以同时收发数据
+ 面向字节流

### 三次握手

1. 客户端发送一个数据包告诉服务器要建立连接
2. 服务器收到后会为该连接分配缓存（队列）和变量，返回确认报文，允许建立连接
3. 最后客户端需要给服务器一个返回确认，意思收到了服务器的确认请求，要开始正式发送数据了。两者状态都变为 ESTABLISHED

### 为什么不能用两次握手

主要是为了**防止已失效的连接请求报文段突然又传到服务器，因而产生错误**。 

在网络拥堵情况下，客户端发送连接的请求可能迟迟到不了服务端，这是客户端在超时后会重发请求。如果双方通信结束后，那个失效的连接请求倒了服务端，由于只有两次握手，那么服务端收到请求后误以为客户端又发送了一次新的连接请求，于是又会进入状态等待客户端发送数据，而此时客户端已经关闭，服务端会一直等下去。

同时，两次握手情况下，服务器端对客户端的起始序列号做了确认，而客户端却没有确认，因此无法保证传输的可靠性

### 四次挥手

1. 客户端发起请求，请求断开连接
2. 服务器收到请求后，返回确认信息，此时客户端不能给服务器发送报文。
3. 当服务器没有可传的信息后，会给客户端发送请求结束的报文
4. 客户端收到报文后返回确认报文，发送完毕后，等待两个时间周期后关闭

服务器收到客户端请求后，必须等到服务端所有的报文都发送完毕了，再发送 FIN 的请求。因此会先发送表示收到客户端请求，延时一段时间后再发送同意关闭

### 建立连接后，客户端故障

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个 探测报文段 ，以后则每隔 75 秒钟发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。





