[巩固你的HTTP知识体系](https://juejin.im/post/6857287743966281736)

TCP

概念、与 UDP 区别、三次握手、四次挥手

https://juejin.im/post/6844904070889603085

前端代码部署

https://www.zhihu.com/question/20790576/answer/32602154



## HTTP

超文本传输协议

### 特点

+ 灵活可拓展，可以传输文本、图片、视频等
+ 请求 - 应答模式
+ 可靠，基于 TCP/IP
+ 无状态，**请求都是独立的**，服务器不会记录客户端状态，不知道客户端是谁除非客户端带上自己的状态（依靠 cookie、session），对于同一个接口的请求也没有上下文关系。
+ 明文传输，将报文暴露给外界

### 1.0/1.1/1.2 区别

#### 1.0

+ 引入了 POST 和 HEAD
+ 不支持断点续传
+ 非持久连接，每次请求都需要重新建立 tcp 连接

#### 1.1 

最主流的版本

+ 引入持久连接，TCP 连接默认不关闭（Keep-Alive），可以被多个请求复用
+ 在同一个 TCP 连接里，客户端可以同时发送多个请求
+ 增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效
+ 支持断点续传
+ 新增 PUT、PATCH、OPTIONS、DELETE 

### 1.x 版本的问题

+ 传输数据明文
+ 允许复用 TCP 连接的前提下，在同一个 TCP 连接内每次只能够处理一个回应，可能会造成队头阻塞。如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。
+ 默认开启 keep-alive 的情况下可能会给服务器带来压力，可能存在请求之后还保持了长时间不必要的连接

### 2.0

+ 二进制分帧： 之前是明文传输，2.0 采用了二进制的格式， 头信息和数据体都是二进制，统称为帧
+ 头部压缩：1.1 版本会出现头部偏重（**User-Agent、Cookie、Accept、Server、Range**等字段占用过多）而 body 偏小的情况，在 2.0 中使用了算法进行压缩
+ 多路复用 ：同样是复用 TCP 连接，**在一个连接里，客户端和浏览器都可以同时发送多个请求**，单个连接可以承载任意数量的双向数据流，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。
+ 服务器推送：允许服务器未经请求，主动向服务端发送资源，即服务器推送
+ 请求优先级：可以设置数据帧的优先级，让服务端优先处理重要资源



## 状态码

+ 1xx  请求已经接受，需要继续处理
+ 2xx 成功状态
  + 200 OK 表示客户端请求在服务器端被正确请求
  + 204 请求成功但无资源返回
  + 206 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 **「Content-Range」** 指定范围的实体内容。
+ 3xx 重定向
  + 301 永久重定向，表示资源已经分配了新的 URL
  + 302 临时重定向，表示资源临时被分配了新的 URL
  + 303 表示资源存在另一个 URL，应使用 GET 方法获取资源
  + 304 命中**协商缓存**
  + 307 临时重定向，不会改变 method。由于 301、302、303 返回时，浏览器会将 post 改成 get，自动再次发送。
+ 4xx 客户端错误
  + 400 请求报文语法错误
  + 401 表示发送的请求需要有通过 HTTP 认证的认证信息。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
  + 403 请求资源访问被拒绝
  + 404 没找到该资源
  + 405 禁止使用该请求方式，通常客户端可以通过 options 方法进行预检，查看服务器允许的方法 `Access-Control-Allow-Methods`
+ 5xx 服务器错误
  + 500 服务器执行请求时错误
  + 502 服务器自身正常，访问时出现了未知问题
  + 503 服务器超负荷或停机维护，无法处理请求



## Keep-Alive

目的在于使客户端到服务器端的连接持续有效，让多次的 http 请求复用同一个 tcp 连接，从而减少创建关闭多个 tcp 连接的开销。

开启方法是在头部增加 `connection: Keep-Alive`，1.1 默认启用。关闭则需要设置 `Connection: close`

需要依赖服务器的设置情况



## DNS

DNS 协议提供的是一种**主机名到 ip 地址的转换服务**。应用层协议，运行在 UDP 协议之上（**为了避免使用 TCP 协议时造成的连接时延**）。

DNS 服务器收到一个 DNS 回答后，能够将回答中的信息缓存在本地存储器中。

### DNS 实现负载均衡

在网站使用多台服务器时，一个域名会对应多个服务器地址。在用户发起网站域名的 DNS 请求时，会返回域名对应的服务器 ip 集合，在每个回答中会循环这些 ip 地址的顺序，用户会选择排在前面的地址发送请求，以此实现将用户请求均衡地分配到各个不同服务器上。

该方法的问题在于，如果一个服务器有问题时，由于 DNS 服务器中有缓存，会仍然将域名解析为可能发生故障的服务器 ip。



## HTTP 缓存

缓存是性能优化的一个重要手段。

### 强缓存

相关字段：Expires（1.0 版本），Cache-Control（1.1 版本）

首先检查强缓存，这个阶段不需要发送 HTTP 请求。通过上述两个字段来进行判断。

#### Expires

过期时间，时间是相对于服务器来说。存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里获取数据，无需再次请求

```
Expires:Mon, 29 Jun 2020 11:10:23 GMT
```

由于**服务器时间与浏览器时间可能不一致**，因此在 1.1 版本中使用 Cache-Control 来替代

#### Cache-Control 

- private：客户端可以缓存
- public：客户端和代理服务器都可以缓存
- max-age=t：缓存内容将在t秒后失效
- no-cache：需要使用协商缓存来验证缓存数据，因此是需要去向服务器验证缓存是否可用
- no-store：所有内容都不会缓存

```
Cache-Control:max-age=6000
```

表示资源返回后 6000 秒，可以直接使用缓存

#### 注意点

+ 当上述两个字段同时存在时，优先考虑 Cache-Control 
+ 没有命中强缓存时，会进入协商缓存

### 协商缓存

强缓存失效后，浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，浏览器再次请求时，请求头中携带响应的`缓存相关的Tag`来向服务器发送请求，服务器根据对应的 tag，来决定是否使用缓存。未失效则返回 304。

缓存分为两种，**Last-Modified** 和 **ETag**。两者各有优势，并不存在谁对谁有`绝对的优势`，与上面所讲的强缓存两个Tag所不同。

#### Last-Modified

资源最后的修改时间。

+ if-Modified-Since

  在浏览器第一次给服务器发请求时，会在响应头中加上这个字段。浏览器再次请求时，会在请求头中携带 **If-Modified-Since** 字段这个值就是服务器传来的最后修改时间。服务器拿到这个字段后会与该资源的最后修改时间进行对比，如果小于最后修改时间，说明该资源已经更新过了，返回新的资源。否则返回 304，告诉浏览器使用缓存。

+ if-Unmodified-Since

  从某个时间点开始，文件是否没有被修改，如果没有被修改，返回200。反之返回 412 （预处理错误）

#### ETag

服务器根据当前文件内容，生成文件唯一标识。如果资源内容修改，这个值就修改。

+ if-None-Match

  服务器同样会通过响应头 ETag 把该字段告诉浏览器，浏览器下次请求该资源时，会携带 **If-None-Match** 这个字段。服务器收到后会与该资源的 ETag 进行对比，如果不同则说明内容更新，返回新资源。否则返回 304，使用缓存。

+ if-Match

  与前者相反，相同执行请求，否则拒绝（412）

#### 二者对比

性能上考量，Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，因此 Last-Modified 优于 ETag。

从精确程度上看，ETag 更优。在某些情况下，例如编辑了资源文件但文件内容没有改变，或是1秒内改变了多次（最小粒度只到 s， s 以内的改动无法检测到）的情况， Last-Modified 不能够很好的判断。

如果两种方法都支持的情况，服务器优先考虑 ETag

### 缓存位置

浏览器缓存的存放位置分四种，按优先级从高到低：

1. Service Worker

   多应用于 PWA 场景，能够完成**离线缓存**的功能

2. Memory Cache

   内存缓存，效率最高。浏览器关闭后，内存缓存也不存在了。

3. Disk Cache

   磁盘缓存，存取效率低于内存缓存，优势在于存储容量与存储时长，大的资源文件（图片、js、css）优先考虑存放在 Disk

4. Push Cache

   推送缓存



## 请求方法

HTTP 1.0 GET｜POST｜HEAD

HTTP 1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

### GET 与 POST 的区别

+ 通常在对于参数的处理上，get 请求会放在 URL 中，POST 则会放在 body 请求体中，相对而言安全一些，但在抓包的情况下都一样
+ GET 请求要经过 URL 编码，只能够接受 ASCII 码，POST 支持更多中编码类型且不对数据类型限制
+ 缓存角度来说，GET 请求后浏览器会主动缓存
+ GET 请求会一次性发送请求报文，POST 请求通常分为两个 TCP 包，首先发送 header 部分，服务器响应 100 后，在发送 body 部分

### OPTIONS 的作用

这个方法会返回该资源所支持的所有 HTTP 方法，在 CORS 跨域资源共享时，对于非简单请求会先发送一次 OPTIONS 请求，判断是否有访问的权限（请求方法以及 header 额外字段）



## 队头阻塞问题

对于每一个 HTTP 请求而言，任务会被放入任务队列中串行执行，一旦队头的任务请求太慢，就会阻塞后面的请求处理。

解决办法：

+ 并发：一个域名可以分配多个长连接，即增加了任务队列。Chrome 中是 6 个
+ 域名分片：可以划分出多个二级域名，指向同一个服务器。这样可以增加并发处理的任务队列。例如 test.com 划分出 child1.test.com 、child2.test.com



## HTTPS

HTTPS 是由 HTTP + TLS/SSL 协议组合而成。由后者来保障安全性。

与 HTTP 的区别在于：

+ HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
+ HTTPS 对于 SEO 更为友好，谷歌、百度会优先检索 HTTPS 网页
+ HTTPS 标准端口 443，HTTP 标准端口为 80
+ HTTPS 需要 SSL 证书

主要作用：

+ 对数据进行加密，建立一个信息安全通道
+ 对网站服务区进行真实身份认证

### 工作原理

基于 TLS/SSL 的功能，依赖三类基本算法：散列函数（信息完整）、对称加密、非对称加密

客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个**「对称加密的秘钥」**，使用**「该公钥」**加密，传输给服务端，服务端再通过解密拿到该**「对称秘钥」**，后续的所有信息都通过该**「对称秘钥」**进行加密解密，完成整个HTTPS的流程。

TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。



## WebSocket

WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。

使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。



## 负载均衡

### 反向代理

用户的请求都发送到反向代理服务器上，由反向代理服务器（例如 Nginx）将请求转发到真实的服务器上，实现负载均衡。

### DNS

参考 DNS 部分



## TCP/IP 

TCP 协议是传输层协议，面向连接的、可靠的、基于字节流的传输层通信协议

+ 面向连接，例如三次握手，四次挥手都是针对连接
+ 一条连接只有两个端点
+ 可靠
+ 全双工：连接双方可以同时收发数据
+ 面向字节流

### 三次握手

1. 客户端发送一个数据包告诉服务器要建立连接
2. 服务器收到后会为该连接分配缓存（队列）和变量，返回确认豹纹，允许建立连接
3. 最后客户端需要给服务器一个返回确认，意思收到了服务器的确认请求，要开始正式发送数据了。

### 为什么不能用两次握手

主要是为了**防止已失效的连接请求报文段突然又传到服务器，因而产生错误**。 

在网络拥堵情况下，客户端发送连接的请求可能迟迟到不了服务端，这是客户端在超时后会重发请求。如果双方通信结束后，那个失效的连接请求倒了服务端，由于只有两次握手，那么服务端收到请求后误以为客户端又发送了一次新的连接请求，于是又会进入状态等待客户端发送数据，而此时客户端已经关闭，服务端会一直等下去。

同时，两次握手情况下，服务器端对客户端的起始序列号做了确认，而客户端却没有确认，因此无法保证传输的可靠性

### 四次挥手

1. 客户端发起请求，请求断开连接
2. 服务器收到请求后，返回确认信息，此时客户端不能给服务器发送报文。
3. 当服务器没有可传的信息后，会给客户端发送请求结束的报文
4. 客户端收到报文后返回确认豹纹，发送完毕后，等待两个时间周期后关闭

服务器收到客户端请求后，会先等到剩余数据全都发送完毕了，在发送同意关闭的请求。因此会先发送表示收到客户端请求，延时一段时间后再发送同意关闭

### 建立连接后，客户端故障

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个 探测报文段 ，以后则每隔 75 秒钟发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。





