## 前置准备

LeetCode 账号

做完题目后查看国际版中 Discuss 区高赞答案 Top 3

## 事件复杂度

### 类型

+ O(1) 常数复杂度
+ O(log n)
+ O(n)
+ O(n^2)
+ O(n^3)
+ O(2^n)
+ O(n!)

### 主定理

+ 二分查找 O(log n)
+ 二叉树遍历 O(n) 每个节点会且仅会访问一次
+ 二维矩阵二分查找 O(n)
+ 合并排序 O( n log n ) best

常见时间复杂度

+ 二叉树前序、中序、后序  O(n)
+ 图的遍历 O(n)
+ 搜索算法：DFS、BFS O(n)
+ 二分查找 O(log n)

数据结构入门题 -> 分类刷题

## 数据结构

+ 数组
+ 链表
+ 队列
+ 栈
+ 哈希表
+ 堆
+ 优先队列
+ 树

# 排序算法

## 插入排序

### 直接插入排序

将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换插入，直到全部元素都比较过。 因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成。

```js
const insertSort = (arr) => {
	for (let i = 0; i < arr.length; i++) {
		for (let j = i; j >= 0; j--) {
			if (arr[j] < arr[i]) {
				arr.splice(j + 1, 0, arr.splice(i, 1)[0])
				break
			} else if (j === 0) {
				arr.splice(j, 0, arr.splice(i, 1)[0])
			}
		}
	}
	return arr
}
```

### 希尔排序

取一个小于n的整数h，数组项之间间隔 h 的为一组，共分成 h 组，针对这 h 组进行直接插入排序。接着不断减小 h 的值，重复上述步骤，直到 h 变为 1，即所有的的数组项都放在同一组内进行直接插入排序。

相对比于直接使用直接插入排序，希尔排序优化了大规模乱序数组中插入排序慢的问题。

```js
const shellSort = arr => {
	let h = arr.length;
	while (true) {
		h = Math.floor(h / 2)
		for (let x = 0; x < h; x++) {
			// 间隔 h 分组，组内直接插入排序
			for (let i = x + h; i < arr.length; i = i + h) {
				let temp = arr[i]
				let j
				for (j = i - h; j >= 0; j = j - h) {
					if (arr[j] > temp) {
						arr[j + h] = arr[j]
					} else {
						break
					}
				}
				arr[j + h] = temp;	
			}
		}
    // 当增量 h 为 1 时，跳出循环
		if (h === 1) {
			break
		}
	}
	return arr
}
```

由于 h 选择的原因，希尔排序目前的性能还没有被完全研究透彻，即使是如上代码对h的选择也是。

而在实际应用中，希尔排序适合中等大小的数组，它的代码量小，较为简单，同时不占同额外的空间。但是对于规模很大的数组，希尔排序的表现可能就没那没好了，不及有如快排等的算法。工程实践中，比如工程初始阶段可以使用希尔排序，而后续阶段再考虑是否使用更复杂的排序算法。

## 选择排序


### 选择排序

从待排序序列中，找到关键字最小的元素; 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换; 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。 

```js
const selectSort = (arr) => {
	for (let i = 0; i < arr.length; i++) {
		let maxValue = -Infinity
		let maxIndex = 0
		for (let j = i; j < arr.length; j++) {
			if (maxValue < arr[j]) {
				maxValue = arr[j]
				maxIndex = j
			}
		}
		;[arr[i], arr[maxIndex]] = [arr[maxIndex], arr[i]]
	}
	return arr
}
```

### 堆排序

堆的特征

+ 堆的数据结构近似完全二叉树，即每个节点存在两个子节点
+ 当节点的值小于等于父节点，大于等于子节点，称为大顶堆（根节点值最大）
+ 当节点的值大于等于父节点，小于等于子节点，称为小顶堆（根节点值最小）
+ 当前节点索引为 k 时，左子节点索引为 2k + 1，右子节点为 2k + 2 （索引值每层从左至右递增）

排序方法

1. 首先将数组构造成一个大顶堆，此时根节点最大
2. 将最后一个节点与根节点交换，并剔除根节点
3. 将剩下的节点重复构造大顶堆
4. 循环 2、3 步骤直到堆中只有 1 个元素

## 交换排序

### 冒泡排序

对相邻的元素进⾏**两两⽐较**，顺序相反则进⾏交换，这样，每⼀趟会将最⼩或最⼤的元素“浮”到顶端， 最终达到完全有序。（始终移动最⼤或最⼩的⼀个）

```js
// 冒泡排序 好 O(n) 坏 O(n^2) 平均 O(n^2)
const bubbleSort = (arr, judge) => {
	for (let i = arr.length; i > 0; i--) {
		// const element = arr[i];
		for (let j = 0; j < i - 1; j++) {
			if (judge(arr[j], arr[j + 1])) {
				// 纯数字的情况
				;[arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]
			}
		}
	}
	return arr
}
```

### 快速排序（分治）

从序列当中选择一个**基准数(pivot)**，在这里我们选择序列当中第一个数最为基准数；将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧；针对左右两侧的子集进行相同的操作，直到子集只有一个元素

```js
// 空间复杂度较高
const quickSort = (arr) => {
	if (arr.length <= 1) return arr
	let pivot = Math.floor((arr.length - 1) / 2)
	const val = arr[pivot]
	let less = []
	let more = []
	arr.splice(pivot, 1)
	arr.forEach((i) => {
		if (i < val) {
			less.push(i)
		} else {
			more.push(i)
		}
	})
	return quickSort(less).concat([val], quickSort(more))
}

// 优化版本
const updateQuickSort = (arr, start, end) => {
	if (start >= end) {
		return
	}
	let startIndex = start
	let endIndex = end
	let pivot = arr[start]

	while (startIndex < endIndex) {
		// from right to left
		while (startIndex < endIndex && arr[endIndex] > pivot) {
			endIndex--
		}
		arr[startIndex] = arr[endIndex]

		// from left to right
		while (startIndex < endIndex && arr[startIndex] <= pivot) {
			startIndex++
		}
		arr[endIndex] = arr[startIndex]
	}
	arr[startIndex] = pivot
	updateQuickSort(arr, start, startIndex - 1)
	updateQuickSort(arr, startIndex + 1, end)

	return arr
}
```



## 归并排序（回溯）

将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 

```js
function merge(left, right) {
  let result = []
  while(left.length > 0 && right.length > 0) {
    if (left[0] < right[0]) {
      result.push(left.shift())
    } else {
      result.push(right.shift())
    }
  }
  return result.concat(left).concat(right)
}
const mergeSort = (arr) => {
  if (arr.length === 1) {
    return arr
  }
  const middleIndex = Math.floor(arr.length / 2)
  const left = arr.slice(0, middleIndex)
  const right = arr.slice(middleIndex)
  return merge(mergeSort(left), mergeSort(right))
}
```



## 基数排序







