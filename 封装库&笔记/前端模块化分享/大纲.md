大纲

1. 使用 script 标签引入（demo 2张）

   1. 简单描述执行结果，期望打印出1，结果收到作用域影响打印出2

   2. 简述问题：1）所有变量在全局作用域，可能会重名等；2）模块之间的依赖关系不清晰；3）需要额外关注加载顺序，如有变动需要手动维护。

   3. 引出模块化的概念与要求：变量作用域（不相互影响，冲突）、（由于难看出依赖关系，所以）模块间有导入导出的方法，加载执行有规范，保证彼此的依赖关系。

   4. （转场）但是 JavaScript 这⻔语⾔在 Ecmascript6 规范之前并没有语⾔层⾯的模块导⼊导出关键词及相关规范。 

      为了解决这样的问题，不同的 JS 运⾏环境分别有着⾃⼰的解决⽅案。（CommonJS、AMD、UMD）

2. CommonJS Node

   1. 简单介绍 CommonJS
   2. 引出例子，  解释运行结果 
   3. 切回例子，说明 该规范如何解决了痛点：1）有相同的变量 m，但是没有冲突；2）模块间有导入导出的方式，依赖关系清晰
   4. 特点：1）仅限 Node 环境；2）同步加载（模块化文件一般存在本地，加载比较快）；3）单例（结果被加载后就被缓存）
   5. （转）这是在 Node 环境下的模块化规范，前端更熟悉的浏览器端环境下实现的是 AMD 的模块化规范

3. AMD Web

   1. 介绍 AMD，强调异步（通过请求加载网络资源，异步是为了不阻塞页面的加载）
   2. 改写之前的例子，介绍 require、define 方法。模块的 ID 默认为文件名。由于是浏览器环境下的规范，需要在 html 文件中加载入口模块，需要额外引入 AMD 库。
   3. 演示结果，切会例子介绍 CMD，用到的时候再加载
   4. 介绍特点；使用麻烦 依赖 AMD 库 ； 在微前端领域使用
   5. （转）如果需要一个模块同时运行在浏览器和 Node 环境中，那么就需要分别维护两套代码，基于这样的问题，出现了 UMD 这种同构方案。

4. UMD 兼容 CommonJS 和 AMD

   1. 用法介绍
   2. 查看 Vue 源码中的 UMD 应用
   3. 第三方库的应用比较广泛
   4. （转场）总结 CommonJS 与 AMD 的特点（运行环境实现，相互之间无法共用模块），引入 ES6 模块化规范 ESM。

5. ES Module

   1. 基本使用
   2. 与 前两者的区别
      
      1. 前两者为缓存，后者为引用
      2. 静态编译
      3. 前两者由运行环境提供（Node require，AMD requireJS），调用了环境提供的的 require 方法；后者由 JS 解释器（JS 引擎）实现
         1. 介绍图，每个JS 运行环境都有一个解释器（引擎），能够用规范去解释 JS 的语法。
         2. 对于 ESM 来说就是属于 JS Core 底层层面的规范，只要升级到足够的版本就可以使用。Node 在12 之后也可以使用。

6. 后模块化时代

   1. 支持js的环境，随着解释器的升级，最终一定会支持 ESModule 标准。但是浏览器具有分布式的特点，取决于用于访问时的版本。
   2. 为了让新的代码运行在一些老的浏览器上，出现了很多工程化的工具。例如 babel。
   3. babel 会将 import export 编译为 commonjs 规范，这样导致的问题是无法在浏览器端直接运行，因此我们还需要打包 -> webpack
   4. 总结 webpack 和 babel 的作用。
   5. 简单介绍 bundleless 的概念