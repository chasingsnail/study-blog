大纲

1. 使用 script 标签引入

   1. 所有变量在全局作用域，可能会重名等

   2. 模块之间的依赖关系不清晰，需要手动维护 html 文件中的加载顺序

   3. 引出模块化的概念与要求：变量作用域（不相互影响，冲突）、（由于难看出依赖关系，所以）模块间有导入导出的方法，加载执行有规范，保证彼此的依赖关系。

   4. （转场）但是 JavaScript 这⻔语⾔在 Ecmascript6 规范之前并没有语⾔层⾯的模块导⼊导出关键词及相关规范。 

      为了解决这样的问题，不同的 JS 运⾏环境分别有着⾃⼰的解决⽅案。不同的环境有各种的解决方案 （CommonJS、AMD、UMD）

2. CommonJS Node

   1. 例子 介绍用法  由运行结果 切回例子
   2. 优势（作用域、导入导出的方式、单例） 对比模块化要求
   3. 局限（仅限 Node 环境、同步加载）

3. AMD Web

   1. 例子 介绍用法
   2. 演示结果
   3. 对比 CMD  seajs，用到的时候再加载ß
   4. 使用麻烦 依赖 AMD 库 ； 在微前端领域使用

4. UMD 兼容 CommonJS 和 AMD

   1. 用法介绍
   2. 查看 Vue 源码中的 UMD 应用
   3. 第三方库的应用比较广泛

5. ES Module

   1. （转场）总结 CommonJS 与 AMD 的特点，引入 ES6 模块化规范 ESM。
   2. 基本使用
   3. 与 前两者的区别
      1. 前两者由运行环境提供（Node require，AMD requireJS）展示图，后者由 JS 解释器（JS 引擎）实现
      2. 前两者为缓存，后者为引用

6. 后模块化时代

   1. 支持js的环境，随着解释器的升级，最终一定会支持 ESModule 标准。
   2. 为了让新的代码运行在一些老的浏览器上，出现了很多工程化的工具。例如 babel。
   3. babel 会将 import export 编译为 commonjs 规范，这样导致的问题是无法在浏览器端直接运行，因此我们还需要打包 -> webpack
   4. 总结 webpack 和 babel 的作用。
   5. 简单介绍 bundleless 的概念