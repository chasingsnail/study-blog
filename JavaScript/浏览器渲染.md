## 进程与线程

+ 进程是系统分配的独立一块内存运行，进程间相互独立
+ 一个进程可能包含一个或多个线程，多个线程之间共享资源
+ 不同进程之间可以通信，不过代价较大

### 浏览器是多进程的

系统为浏览器分配了资源，每打开一个Tab页，相当于创建了一个**独立的浏览器进程**。

+ Browser进程：主进程主要负责各个进程的创建与销毁，页面前进后退等交互等等。**仅有一个**。
+ 第三方插件进程：每种对应的插件对应一个进程。
+ GPU进程：用户3D绘制等。**最多一个**。
+ 浏览器渲染进程：每个Tab的独立进程主要负责页面渲染，执行脚本，事件处理等。

使用多进程的优势在于

+ 规避了单个页面或插件crash影响整个浏览器的崩溃
+ 利用了多核优势

负面的影响在于消耗的内存等资源更大。

### 渲染进程

一个独立的渲染进程包含了多个线程。

#### GUI渲线程

负责浏览器界面的渲染，解析HTML、CSS、构建DOM等。该线程与JS引擎线程**互斥**，当后者执行时，前者会被挂起，等到后者空闲时立即被执行（网页加载阻塞原因之一）。

#### JS引擎线程

负责处理JavaScript脚本程序，例如 V8 引擎。无论何时只有**一个JS线程**在运行JS程序。单线程的设计考虑到浏览器操作的复杂性，多线程的运行可能会修改彼此的运行结果。

#### 事件触发线程

该线程归属浏览器，用来控制**事件循环（Event Loop）**。当JS引擎执行异步代码块，会将任务添加到事件线程中。当满足触发条件时，等待JS引擎的处理。

#### 定时触发器线程

setTimeout和setInterval所在的线程，它们通过独立的线程来计时，计时完毕后添加到事件队列，等待JS引擎的执行

#### 异步http请求线程

在XHR连接后，通过浏览器新开一个线程，当检测到状态变更且有设置回调函数，异步线程就将这个回调放入事件队列中，再由JS引擎执行。

### 主进程（Browser进程）与浏览器内核（Render进程）的通信

首先，主进程收到用户请求，获取页面内容，将该任务抛给Render进程。Render进程收到消息后，交给渲染线程开始渲染。

渲染进程接收请求后，加载网页并渲染网页，过程中可能需要主进程获取资源以及GPU进程协助渲染。

并可能有JS线程操作DOM。最后Render进程将结果传递给主进程。

主进程接收到结果并将结果绘制出来。

### 线程之间的关系

#### GUI渲染线程与JS引擎线程互斥

由于JS引擎进程是可以**操纵DOM**的，如果修改这些元素的属性同时渲染界面，这样就会有问题。为了防止这种不可预期的结果，浏览器设置二者是呼哧的关系。当JS引擎线程执行时，GUI更新则会被保存在一个队列中等到JS引擎空闲时立即执行。

#### JS阻塞页面加载（页面渲染优化点）

倘若JS执行时间过长，则会阻塞页面。因此要尽量避免JS执行时间过长。

### WebWorker

HTML5中支持了`Web Worker`。

+ 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且**不能操作DOM**）。

+ JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）。

当存在一个非常耗时的工作时，可以单独开一个Worker线程，里面的一切计算都不会影响JS引擎主线程。只有计算完毕后，才会将结果发送给主进程。

```js
// 每 0.5s 递增1 demo
// index.js
var w;

function startWorker() {
    if(typeof(Worker) !== "undefined") {
        if(typeof(w) == "undefined") {
            w = new Worker("demo_workers.js");
        }
        w.onmessage = function(event) {
            document.getElementById("result").innerHTML = event.data;
        };
    } else {
        document.getElementById("result").innerHTML = "抱歉，你的浏览器不支持 Web Workers...";
    }
}

function stopWorker() 
{ 
    w.terminate();
    w = undefined;
}

// demo_workers.js
var i=0;

function timedCount() {
    i=i+1;
    postMessage(i);
    setTimeout("timedCount()",500);
}

timedCount();
```



### script标签（带有src属性）

![](https://img-blog.csdnimg.cn/20190120161519895.png)

+ 无defer或async属性，浏览器会立即下载并执行脚本，下载和执行时页面处理停止。
+ 带有defer属性，浏览器会立即下载相应的脚本，下载时页面处理不会停止。**等到文档解析完成**后脚本才会执行。
+ 带有async属性，浏览器会立即下载相应的脚本，下载时页面处理不会停止。**下载完成后立即执行**，执行过程中页面处理会停止。
+ 同时指定async、defer，则会按async属性处理。

## 浏览器渲染流程梳理

### 渲染步骤

浏览器输入URL后，由主进程接管，开启一下下载线程，当获取到内容之后，交给浏览器渲染进程。

![](https://user-gold-cdn.xitu.io/2018/1/22/1611cb18d3a3938b?imageslim)

1. 解析HTML建立DOM树
2. 解析CSS，结合DOM合并为render树
3. 布局render树（layout/reflow），进行各元素尺寸、位置的计算
4. 绘制render树（paint），绘制页面像素信息
5. 浏览器将各层信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

### load与DOMContentLoad

在渲染完毕后，会触发load事件。

DOMContentLoaded 事件在 **html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发**。

当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。

### css加载的阻塞问题

这里特指头部引入css的情况。

css是由单独的下载线程异步下载的，不会阻塞DOM树解析，但是会**阻塞render树渲染**。

当加载css时，也许会修改DOM节点的样式，如果css的加载不阻塞渲染，也许当加载完成后，render树需要重绘或回流。因此等待css加载完成后在来渲染render树相当于一种优化的机制。

### 图层合成渲染

浏览器渲染的图层一般包含：普通图层与复合图层（Composited Layer）。

#### 普通文档流

普通文档流可以理解为一个复合图层，即**默认复合图层**。无论里面有多少元素，都是同一个复合图层。

#### 脱离普通文档流

例如absolute、fixed布局，同样仍然**属于默认复合图层**。因此，当absolute中的信息改变时，会影响整个复合图层的绘制。

#### 硬件加速

开启硬件加速则是直接开启了另一个复合图层，它的改变不会影响到默认复合图层。

由于在GPU中，各个复合图层时单独绘制互不影响到的，可以通过硬件加速来变为新的复合图层，达到加速效果。

常用的开启硬件加速的方法：

+ translate3d、translateZ
+ opacity（过渡动画）
+ canvas、、video、iframe、webgl

注意点：

在使用3D硬件加速提升动画性能时，最好给元素增加一个**z-index属性**，人为干扰复合层排序。原因在于如果该元素的z-index较低，则在其之后（层级高于该元素且为relative或absolute定位）的元素也会变为复合层渲染，这样会产生极大的性能影响。可以通过 devtool -> render 查看黄色线框（复合图层）的图层

## 参考

[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7)

[深入解析浏览器的幕后工作原理](https://www.cnblogs.com/lhb25/p/how-browsers-work.html)